<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialise variables
level_width = 5;
level_height = 5;

currRX = level_width div 2;
currRY = level_height div 2;

transitionRate = 0.08;
transitionDuration = room_speed;
transitionTimer = transitionDuration;

nextRoom = ds_map_create();
nextRoom[? 'dx'] = currRX;
nextRoom[? 'dy'] = currRY;
nextRoom[? 'room'] = noone;
nextRoom[? 'entering'] = true;
nextRoom[? 'player'] = noone;

randomize();
global.seed = random_get_seed();


var player = instance_find(obj_player, 0);
if(player != noone){
    player.x = room_width div 2;
    player.y = room_height div 2;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create level
for(var yy = 0; yy &lt; level_height; yy++){
    for(var xx = 0; xx &lt; level_width; xx++){
        rooms[xx, yy] = ds_map_create();
        var r = rooms[xx, yy];
        r[? 'right'] = false;
        r[? 'down'] = false;
        r[? 'left'] = false;
        r[? 'up'] = false;
        r[? 'canEnter'] = false;
        r[? 'hasVisited'] = false;
        r[? 'hasCleared'] = false;
        r[? 'isExit'] = false;
    }
}


var steps = level_width * level_height * (0.2 + random(0.65));
var dir = irandom(3);
var xx = level_width div 2;
var yy = level_height div 2;
var r = rooms[xx, yy];

for(var i = 0; i &lt; steps; i++){
    if(irandom(100) &lt; 50){
        var tempDir = dir;
        while(dir == tempDir)
            dir = irandom(3);
    }
    switch(dir){
        case 0:
            if(xx + 1 &lt; level_width){
                var r1 = rooms[xx, yy];
                r1[? 'right'] = true;
                xx++;                
                var r2 = rooms[xx, yy];
                r2[? 'left'] = true;
            }
        break;
        case 1:
            if(yy + 1 &lt; level_height){
                var r1 = rooms[xx, yy];
                r1[? 'down'] = true;
                yy++;
                var r2 = rooms[xx, yy];
                r2[? 'up'] = true;
            }
        break;
        case 2:
            if(xx - 1 &gt;= 0){
                var r1 = rooms[xx, yy];
                r1[? 'left'] = true;
                xx--;  
                var r2 = rooms[xx, yy];
                r2[? 'right'] = true;
            }
        break;
        case 3:
            if(yy - 1 &gt;= 0){
                var r1 = rooms[xx, yy];
                r1[? 'up'] = true;
                yy--;
                var r2 = rooms[xx, yy];
                r2[? 'down'] = true;
            }
        break;
    }
    var r = rooms[xx, yy];
    r[? 'canEnter'] = true;
}



// Pick the exit
var validRooms = ds_list_create();
var inverter = point_distance(0, 0, level_width div 2, level_height div 2);
for(var yy = 0; yy &lt; level_height; yy++){
    for(var xx = 0; xx &lt; level_width; xx++){
        var r = rooms[xx, yy];
        if(r[? 'canEnter']){
            var rank = inverter - point_distance(xx, yy, level_width div 2, level_height div 2);
            if(rank &lt; 0)
                rank = 0;
            
            if(r[? 'right'] + r[? 'down'] + r[? 'left'] + r[? 'up'] == 1 &amp;&amp; (xx != level_width div 2 &amp;&amp; yy != level_height div 2)){
                rank = 0;
            }
            
            ds_list_insert(validRooms, rank, r); 
        }
    }
}

var exitRoom = ds_list_find_value(validRooms, 0);
exitRoom[? 'isExit'] = true;

var entrance = rooms[level_width div 2, level_height div 2];
entrance[? 'hasCleared'] = true;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

if(transitionTimer &gt; 0){
    transitionTimer -= transitionDuration * transitionRate;
    
    if(transitionTimer &lt;= 0){
        if(!nextRoom[? 'entering']){ // if not entering
            player = nextRoom[? 'player'];
            if(nextRoom[? 'dx'] == 1){ // Right
                player.x = room_width * 0.25;
            }else if(nextRoom[? 'dy'] == 1){ // Down
                player.y = room_height * 0.25;
            }else if(nextRoom[? 'dx'] == -1){ // Left
                player.x = room_width * 0.75;
            }else if(nextRoom[? 'dy'] == -1){ // Up
                player.y = room_height * 0.75;
            }
            currRX += nextRoom[? 'dx'];
            currRY += nextRoom[? 'dy'];
            room_goto(nextRoom[? 'room']);
            transitionTimer = transitionDuration
            nextRoom[? 'entering'] = true;
        }
        nextRoom[? 'room'] = noone;
    }
}else if(nextRoom[? 'room'] != noone){
    transitionTimer = transitionDuration;
}

var thisRoom = rooms[currRX, currRY];
if(!removedBlocks &amp;&amp; instance_number(obj_enemy) &lt;= 0){
    thisRoom[? 'hasCleared'] = true;
    
    // Create a list of blocks
    var blocks = ds_list_create();
    for (var i = 0; i &lt; instance_number(obj_bridge_block); i++){
        ds_list_add(blocks, instance_find(obj_bridge_block,i));
    }
    for (var i = 0; i &lt; ds_list_size(blocks); i++){    
        with(blocks[|i]){
            instance_destroy();
        }
    }
    
    removedBlocks = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
var thisRoom = rooms[currRX, currRY];
thisRoom[? 'hasVisited'] = true;
var right = thisRoom[? 'right'], down = thisRoom[? 'down'], left = thisRoom[? 'left'], up = thisRoom[? 'up'];

removedBlocks = false;

// Create a list of walls
var walls = ds_list_create();
for (var i = 0; i &lt; instance_number(obj_invisible_wall); i++){
    ds_list_add(walls, instance_find(obj_invisible_wall,i));
}

// Loop through the walls removing irrelevant bridges
for (var i = 0; i &lt; ds_list_size(walls); i++){
   var wall = walls[|i];
   
   with(wall){
       if (collision_line(0, room_height div 2, room_width div 2, room_height div 2, id, false, false)){
            // Left
            if(left){
                instance_destroy();
            }else{
                removeBridgeThroughCollision();
            }
       }else if (collision_line(room_width, room_height div 2, room_width div 2, room_height div 2, id, false, false)){
            // Right
            if(right){
                instance_destroy();
            }else{
                removeBridgeThroughCollision();
            }
       }else if (collision_line(room_width div 2, room_height div 2, room_width div 2, 0, id, false, false)){
            // Up
            if(up){
                instance_destroy();
            }else{
                removeBridgeThroughCollision();
            }
       }else if (collision_line(room_width div 2, room_height div 2, room_width div 2, room_height, id, false, false)){
            // Down
            if(down){
                instance_destroy();
            }else{
                removeBridgeThroughCollision();
            }
       }
   }
}

if(!thisRoom[? 'hasCleared']){
    if(thisRoom[? 'isExit']){
        instance_create(room_width div 2, room_height div 2, choose(obj_vine_boss, obj_boss_slime));
    }else{
        var spawner = instance_create(room_width div 2, room_height div 2, obj_enemy_spawner);
        spawner.objMobType = choose(obj_slime, obj_mushroom, obj_skeleton);
    }
}
thisRoom[? 'hasCleared'] = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Map GUI

var mapScale = 15;
var xOffset = view_wport - mapScale * level_height - 10;
var yOffset = 10;
var dirOffset = mapScale div 3;

var seenAll = true;
for(var yy = 0; yy &lt; level_height; yy++){
    for(var xx = 0; xx &lt; level_width; xx++){
        var r = rooms[xx, yy];
        if(r[? 'right'] + r[? 'down'] + r[? 'left'] + r[? 'up'] != 0 &amp;&amp; !r[? 'hasVisited'])
            seenAll = false;
    }
}

for(var yy = 0; yy &lt; level_height; yy++){
    for(var xx = 0; xx &lt; level_width; xx++){
        var r = rooms[xx, yy];
        if(r[? 'hasVisited']){
            draw_set_colour(c_white);
        }else{
            if(seenAll){
                draw_set_colour(make_colour_rgb(40, 40, 40));
            }else{
                draw_set_colour(c_gray);
            }
        }
        draw_rectangle(xx*mapScale + xOffset, yy*mapScale + yOffset, xx*mapScale + mapScale + xOffset, yy*mapScale + mapScale + yOffset, false);
        
        if(xx == currRX &amp;&amp; yy == currRY){
            draw_set_colour(make_colour_rgb(198, 39, 121));
            draw_rectangle(xx*mapScale + xOffset + 1, yy*mapScale + yOffset + 1, xx*mapScale + mapScale + xOffset - 1, yy*mapScale + mapScale + yOffset -1, true);
        }
        draw_set_colour(c_black);
        draw_rectangle(xx*mapScale + xOffset, yy*mapScale + yOffset, xx*mapScale + mapScale + xOffset, yy*mapScale + mapScale + yOffset, true);
        
        if(r[? 'hasVisited']){
            if(r[? 'left']){
                draw_set_colour(c_black);
                draw_line(xx*mapScale + mapScale div 2 - dirOffset + xOffset, yy*mapScale + mapScale div 2 + yOffset, xx*mapScale + xOffset, yy*mapScale + mapScale div 2 + yOffset);
            }
            if(r[? 'right']){
                draw_set_colour(c_black);
                draw_line(xx*mapScale + mapScale div 2 + dirOffset + xOffset, yy*mapScale + mapScale div 2 + yOffset, xx*mapScale + mapScale + xOffset, yy*mapScale + mapScale div 2 + yOffset);
            }
            
            if(r[? 'up']){
                draw_set_colour(c_black);
                draw_line(xx*mapScale + mapScale div 2 + xOffset, yy*mapScale + mapScale div 2 - dirOffset + yOffset, xx*mapScale + mapScale div 2 + xOffset, yy*mapScale + yOffset);
            }
            if(r[? 'down']){
                draw_set_colour(c_black);
                draw_line(xx*mapScale + mapScale div 2 + xOffset, yy*mapScale + mapScale div 2 + dirOffset + yOffset, xx*mapScale + mapScale div 2 + xOffset, yy*mapScale + mapScale + yOffset);
            }
        }     
    }
}

// Draw player
for (var i = 0; i &lt; instance_number(obj_player); i++){
    var player = instance_find(obj_player,i);
    
    var xx = currRX*mapScale + (player.x / room_width) * mapScale + xOffset;
    var yy = currRY*mapScale + (player.y / room_height) * mapScale + yOffset;
    
    draw_set_colour(c_green);
    draw_rectangle(xx, yy, xx+1, yy+1 , false);
        
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Room Transition

if(transitionTimer &gt; 0){
    var tempAlpha = draw_get_alpha();

    if(nextRoom[? 'entering']){
        draw_set_alpha(transitionTimer / transitionDuration);
    }else{
        draw_set_alpha(1.0 - transitionTimer / transitionDuration);
    }
    draw_set_color(c_black);
    draw_rectangle(0, 0, view_wport, view_hport, false);
    
    draw_set_alpha(tempAlpha);
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
